import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_reactive_ble/flutter_reactive_ble.dart';
import 'package:permission_handler/permission_handler.dart';

void main() => runApp(const MyApp());

class MyApp extends StatelessWidget {
  const MyApp({super.key});
  @override
  Widget build(BuildContext context) => const MaterialApp(home: BleTestScreen());
}

class BleTestScreen extends StatefulWidget {
  const BleTestScreen({super.key});
  @override
  State<BleTestScreen> createState() => _BleTestScreenState();
}

class _BleTestScreenState extends State<BleTestScreen> {
  final _ble = FlutterReactiveBle();

  final Uuid serviceUuid = Uuid.parse("0000ffe0-0000-1000-8000-00805f9b34fb");
  final Uuid characteristicUuid =
      Uuid.parse("0000ffe1-0000-1000-8000-00805f9b34fb");
  final String expectedName = "ESP32_NimBLE"; // opcional: para mostrar en UI

  DiscoveredDevice? targetDevice;
  QualifiedCharacteristic? targetChar;
  bool isConnected = false;

  StreamSubscription<DiscoveredDevice>? _scanSub;
  StreamSubscription<ConnectionStateUpdate>? _connSub;

  @override
  void initState() {
    super.initState();
    _requestPermissions().then((_) => _startScan());
  }

  @override
  void dispose() {
    _scanSub?.cancel();
    _connSub?.cancel();
    super.dispose();
  }

  Future<void> _requestPermissions() async {
    // Android 12+: BLUETOOTH_SCAN / CONNECT; en versiones anteriores, ubicaci√≥n.
    await [
      Permission.bluetoothScan,
      Permission.bluetoothConnect,
      Permission.location,
    ].request();
  }

  void _startScan() {
    _scanSub?.cancel();

    // Opci√≥n A (recomendada): filtrar por servicio ‚Üí menos ruido/energ√≠a
    _scanSub = _ble.scanForDevices(withServices: [serviceUuid]).listen((d) {
      debugPrint(
          "SCAN(UUID) -> name='${d.name}' id=${d.id} rssi=${d.rssi} uuids=${d.serviceUuids}");

      // Con filtro por servicio, todo lo que llega ya tiene FFE0.
      // Aceptamos el primero; si quer√©s seleccionar por nombre, pod√©s chequear d.name.
      targetDevice = d;
      _scanSub?.cancel();
      _connectToDevice();
    }, onError: (e) => debugPrint("Scan error: $e"));

    // --- Opci√≥n B (debug): ver TODO y decidir en c√≥digo ---
    // _scanSub = _ble.scanForDevices(withServices: []).listen((d) {
    //   debugPrint(
    //       "SCAN -> name='${d.name}' id=${d.id} rssi=${d.rssi} uuids=${d.serviceUuids}");
    //   final matchesUuid = d.serviceUuids.contains(serviceUuid);
    //   final matchesName = d.name == expectedName && d.name.isNotEmpty;
    //   if (matchesUuid || matchesName) {
    //     targetDevice = d;
    //     _scanSub?.cancel();
    //     _connectToDevice();
    //   }
    // }, onError: (e) => debugPrint("Scan error: $e"));
  }

  void _connectToDevice() {
    final dev = targetDevice;
    if (dev == null) return;

    _connSub?.cancel();
    _connSub = _ble
        .connectToDevice(
          id: dev.id,
          servicesWithCharacteristicsToDiscover: {
            serviceUuid: [characteristicUuid],
          },
          connectionTimeout: const Duration(seconds: 10),
        )
        .listen((update) {
      switch (update.connectionState) {
        case DeviceConnectionState.connected:
          setState(() => isConnected = true);
          targetChar = QualifiedCharacteristic(
            serviceId: serviceUuid,
            characteristicId: characteristicUuid,
            deviceId: dev.id,
          );
          debugPrint("‚úÖ Conectado a '${dev.name.isEmpty ? "(sin nombre)" : dev.name}' (${dev.id})");
          break;
        case DeviceConnectionState.disconnected:
          setState(() => isConnected = false);
          debugPrint("‚ÑπÔ∏è Desconectado. Reintentando scan‚Ä¶");
          _startScan();
          break;
        default:
          // connecting / disconnecting
          break;
      }
    }, onError: (e) {
      debugPrint("‚ùå Error de conexi√≥n: $e");
      setState(() => isConnected = false);
      _startScan();
    });
  }

  Future<void> _sendCommand(int value) async {
    if (!isConnected || targetChar == null) return;
    try {
      // Si tu caracter√≠stica en ESP32 tiene WRITE (con respuesta):
      await _ble.writeCharacteristicWithResponse(targetChar!, value: [value]);

      // Si adem√°s agregaste WRITE_NR en el ESP32 y prefer√≠s sin respuesta:
      // await _ble.writeCharacteristicWithoutResponse(targetChar!, value: [value]);

      debugPrint("üì§ Enviado: 0x${value.toRadixString(16).padLeft(2, '0')}");
    } catch (e) {
      debugPrint("‚ùå Error escribiendo: $e");
    }
  }

  @override
  Widget build(BuildContext context) {
    final nameShown = targetDevice?.name.isNotEmpty == true
        ? targetDevice!.name
        : expectedName; // etiqueta amigable

    return Scaffold(
      appBar: AppBar(title: const Text("BLE ‚Üí ESP32")),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(isConnected
                ? "üîó Conectado a ${nameShown}"
                : "‚è≥ Buscando ${expectedName}‚Ä¶"),
            const SizedBox(height: 20),
            ElevatedButton(
              onPressed: isConnected ? () => _sendCommand(0x01) : null,
              child: const Text("Encender LED (0x01)"),
            ),
            ElevatedButton(
              onPressed: isConnected ? () => _sendCommand(0x02) : null,
              child: const Text("Apagar LED (0x02)"),
            ),
            const SizedBox(height: 12),
            ElevatedButton(
              onPressed: isConnected ? () => _sendCommand(0x03) : null,
              child: const Text("Reiniciar ESP32 (0x03)"),
            ),
            const SizedBox(height: 32),
            Text(
              "Tip: el nombre puede tardar en aparecer; filtrar por UUID es m√°s fiable.",
              style: Theme.of(context).textTheme.bodySmall,
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }
}
